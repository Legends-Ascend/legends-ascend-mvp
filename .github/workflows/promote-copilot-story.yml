name: Promote Copilot Story to Issue
on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  promote:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Promote user stories to issues (grouped by story)
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const pr = context.payload.pull_request
              if (!pr) {
                core.info('No PR in context; skipping')
                return
              }

              const files = await github.paginate(
                github.rest.pulls.listFiles,
                { owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  per_page: 100 }
              )

              const storyFiles = files
                .map(function(f){ return f.filename })
                .filter(function(p){ return p.indexOf('docs/user-stories/') === 0 && p.slice(-3) === '.md' && p !== 'docs/user-stories/README.md' })

              if (!storyFiles.length) {
                core.info('No docs/user-stories/*.md files found; nothing to promote.')
                return
              }

              // Group files by story ID (US-001, US-002, etc.)
              const storyGroups = {}
              for (const path of storyFiles) {
                const match = path.match(/US-(\d+)/)
                const storyId = match ? 'US-' + match[1] : 'general'
                if (!storyGroups[storyId]) storyGroups[storyId] = []
                storyGroups[storyId].push(path)
              }

              const fs = require('fs')
              for (const storyId of Object.keys(storyGroups)) {
                const paths = storyGroups[storyId]
                
                // Find main story file (longest name with story details)
                const mainFile = paths.reduce(function(longest, current) {
                  return current.length > longest.length ? current : longest
                })
                const supportingFiles = paths.filter(function(p) { return p !== mainFile })

                if (!fs.existsSync(mainFile)) {
                  core.info('Main file not found at checkout: ' + mainFile)
                  continue
                }

                // Read main content
                const mainContent = fs.readFileSync(mainFile, 'utf8')
                const match = mainContent.match(/^#\s+(.+)$/m)
                const issueTitle = match ? ('US: ' + match[1]) : ('US: ' + storyId)

                // Build combined body with supporting docs
                let combinedBody = mainContent
                
                if (supportingFiles.length > 0) {
                  combinedBody += '\n\n---\n\n## Supporting Documentation\n\n'
                  for (const supportPath of supportingFiles) {
                    if (fs.existsSync(supportPath)) {
                      const supportContent = fs.readFileSync(supportPath, 'utf8')
                      const fileName = supportPath.replace(/^.*\//, '')
                      combinedBody += '### ' + fileName + '\n\n' + supportContent + '\n\n'
                    }
                  }
                }

                const created = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: issueTitle,
                  body: combinedBody,
                  labels: ['user-story', 'generated', storyId.toLowerCase()]
                })

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body: 'Promoted ' + storyId + ' (' + paths.length + ' files) to issue #' + created.data.number + '.'
                })
              }
            } catch (err) {
              core.setFailed('Promotion failed: ' + (err && err.message ? err.message : String(err)))
            }
